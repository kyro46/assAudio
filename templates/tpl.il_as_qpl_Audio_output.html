{QUESTIONTEXT}
<div id="visualizer" style = "text-align:center;">
    <canvas id="visualizer_{ID}_audio" height="60px"  margin-bottom: 0.5rem;"></canvas>
</div>
<div id="player" style = "text-align:center;">
	<audio id='media_{ID}_audio' controls ></audio>
</div>
<div style = "text-align:center;">
	<button class="btn btn-default" id="confirm_{ID}_audio" type=button>Record</button>
	<button class="btn btn-default" id="pauseRes_{ID}_audio" type=button onclick="onPauseResumeClicked_{ID}_audio()" disabled>Pause</button>
	<button class="btn btn-default" id="stop_{ID}_audio" type=button onclick="onBtnStopClicked_{ID}_audio()" disabled>Finish</button>
</div>
</br>
<div id="confirmation_{ID}_audio" style = "text-align:center; display: none;">
	<strong>This will override the current recording!</strong>
	</br>
	<button class="btn btn-default" id="cancelBtn_{ID}_audio" type=button onclick="">Cancel</button>
	<button class="btn btn-default" id="rec_{ID}_audio" type=button onclick="onBtnRecordClicked_{ID}_audio()">Start recording</button>
</div>
<a style="display: none" id="downloadLink_{ID}_audio" download="mediarecorder_{ID}.webm" name="mediarecorder_{ID}.webm" href></a>
<p style="display: none" id="data_{ID}_audio"></p>

<script>
//Toggle Confirmation dialog
document.getElementById("confirm_{ID}_audio").addEventListener("click", function(){
    document.getElementById("confirmation_{ID}_audio").style.display = "block";
});
document.getElementById("cancelBtn_{ID}_audio").addEventListener("click", function(){
    document.getElementById("confirmation_{ID}_audio").style.display = "none";
});

//Taken from https://jsfiddle.net/sanddune/uubnnr0w/
function convertDataURIToBinary(dataURI) {
	  var BASE64_MARKER = ';base64,';
	  var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
	  var base64 = dataURI.substring(base64Index);
	  var raw = window.atob(base64);
	  var rawLength = raw.length;
	  var array = new Uint8Array(new ArrayBuffer(rawLength));

	  for(i = 0; i < rawLength; i++) {
	    array[i] = raw.charCodeAt(i);
	  }
	  return array;
	}

$(document).ready(function(){
	var previousSolution = 'data:audio/webm;base64,' + document.getElementById('question_{ID}_audio').value;
	var previousSolutionOutput = document.getElementById('media_{ID}_audio');


	if (document.getElementById('question_{ID}_audio').value == '\n' || document.getElementById('question_{ID}_audio').value == '' || document.getElementById('question_{ID}_audio').value == null) {
		//Something useful to do here?
	} else {
		//var base64ToBlob = atob(previousSolution.value);
		previousSolutionOutput.controls = true;
		//previousSolutionOutput.src = "data:audio/webm;base64," . base64ToBlob;
		
		var binary = convertDataURIToBinary(previousSolution);
		var blob = new Blob([binary], {type : 'audio/webm'});		
		var url = window.URL || window.webkitURL;
		previousSolutionOutput.src = url ? url.createObjectURL(blob) : blob;
		previousSolutionOutput.load();
	}
});



// Taken from https://addpipe.com/media-recorder-api-demo/

'use strict';

/* globals MediaRecorder */

// Spec is at http://dvcs.w3.org/hg/dap/raw-file/tip/media-stream-capture/RecordingProposal.html

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;


if(getBrowser() == "Chrome"){
	// TODO insert switch if only audio
	var constraints_video = {"audio": true, "video": {  "mandatory": {  "minWidth": 640,  "maxWidth": 640, "minHeight": 480,"maxHeight": 480 }, "optional": [] } };//Chrome
	var constraints_audio = {"audio": true};//Chrome
}else if(getBrowser() == "Firefox"){
	// TODO insert switch if only audio
	var constraints_video = {audio: true,video: {  width: { min: 640, ideal: 640, max: 640 },  height: { min: 480, ideal: 480, max: 480 }}}; //Firefox
	var constraints_audio = {audio: true}; //Firefox
}

var recBtn_{ID}_audio = document.getElementById('rec_{ID}_audio');	
var confirmBtn_{ID}_audio = document.getElementById('confirm_{ID}_audio');	
var pauseResBtn_{ID}_audio = document.getElementById('pauseRes_{ID}_audio');	
var stopBtn_{ID}_audio = document.getElementById('stop_{ID}_audio');	

//Creating a visual feedback, following https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_Recording_API/Using_the_MediaStream_Recording_API
var canvas_{ID}_audio = document.getElementById('visualizer_{ID}_audio');
var audioCtx_{ID}_audio = new (window.AudioContext || webkitAudioContext)();
var canvasCtx_{ID}_audio = canvas_{ID}_audio.getContext("2d");

var mediaElement_{ID}_audio = document.getElementById('media_{ID}_audio');	
var dataElement_{ID}_audio = document.getElementById('data_{ID}_audio');	
var downloadLink_{ID}_audio = document.getElementById('downloadLink_{ID}_audio');	

//Show the player while recording to present the current length of the recording
//mediaElement_{ID}_audio.controls = false;

function errorCallback(error){
	console.log_{ID}_audio('navigator.getUserMedia error: ', error);	
}

/*
var mediaSource = new MediaSource();
mediaSource.addEventListener('sourceopen', handleSourceOpen, false);
var sourceBuffer;
*/

var mediaRecorder;
var chunks = [];
var count = 0;

function startRecording_{ID}_audio(stream) {
	log_{ID}_audio('Start recording...');
	if (typeof MediaRecorder.isTypeSupported == 'function'){
		/*
			MediaRecorder.isTypeSupported is a function announced in https://developers.google.com/web/updates/2016/01/mediarecorder and later introduced in the MediaRecorder API spec http://www.w3.org/TR/mediastream-recording/
		*/

			if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
				  var options = {mimeType: 'video/webm;codecs=vp9'};
				} else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
				  var options = {mimeType: 'video/webm;codecs=h264'};
				} else  if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
				  var options = {mimeType: 'video/webm;codecs=vp8'};
				}
		
		if (false) { // TODO if only audio, don't use the options
			log_{ID}_audio('Using '+options.mimeType);
			mediaRecorder = new MediaRecorder(stream, options);
		} else {
			log_{ID}_audio('Using audio/webm');
			mediaRecorder = new MediaRecorder(stream);
		}
		
	    visualize(stream);
		$('#visualizer_{ID}_audio').show();
		
	}else{
		log_{ID}_audio('isTypeSupported is not supported, using default codecs for browser');
		mediaRecorder = new MediaRecorder(stream);
	}

	pauseResBtn_{ID}_audio.textContent = "Pause";

	mediaRecorder.start(10);

	var url = window.URL || window.webkitURL;
	mediaElement_{ID}_audio.src = url ? url.createObjectURL(stream) : stream;
	mediaElement_{ID}_audio.play();
	$("#media_{ID}_audio").prop('muted', true);

	mediaRecorder.ondataavailable = function(e) {
		//log('Data available...');
		//console.log(e.data);
		//console.log(e.data.type);
		//console.log(e);
		chunks.push(e.data);
	};

	mediaRecorder.onerror = function(e){
		log_{ID}_audio('Error: ' + e);
		console.log('Error: ', e);
	};


	mediaRecorder.onstart = function(){
		log_{ID}_audio('Started & state = ' + mediaRecorder.state);
	};

	mediaRecorder.onstop = function(){
		log_{ID}_audio('Stopped  & state = ' + mediaRecorder.state);

		
		var blob = new Blob(chunks, {type: "audio/webm"});
		//var blob = new Blob(chunks, {type: "video/webm"});
		chunks = [];

		//save input as base64-string 
  		var answerAudio = document.getElementById('question_{ID}_audio');	
		var reader = new window.FileReader();
		reader.readAsBinaryString(blob); 
		reader.onloadend = function() {
  			var base64 = reader.result;
   			answerAudio.value = btoa(base64);
		}

		var mediaURL = window.URL.createObjectURL(blob);

		downloadLink_{ID}_audio.href = mediaURL;
		mediaElement_{ID}_audio.src = mediaURL;
		downloadLink_{ID}_audio.innerHTML = 'Download file';

		var rand =  Math.floor((Math.random() * 10000000));
		var name  = "media_"+rand+".webm" ;

		downloadLink_{ID}_audio.setAttribute( "download", name);
		downloadLink_{ID}_audio.setAttribute( "name", name);
	};

	mediaRecorder.onpause = function(){
		log_{ID}_audio('Paused & state = ' + mediaRecorder.state);
	}

	mediaRecorder.onresume = function(){
		log_{ID}_audio('Resumed  & state = ' + mediaRecorder.state);
	}

	mediaRecorder.onwarning = function(e){
		log_{ID}_audio('Warning: ' + e);
	};
}

//function handleSourceOpen(event) {
//  console.log('MediaSource opened');
//  sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp9"');
//  console.log('Source buffer: ', sourceBuffer);
//}

function onBtnRecordClicked_{ID}_audio (){
	 document.getElementById("confirmation_{ID}_audio").style.display = "none";
	 if (typeof MediaRecorder === 'undefined' || !navigator.getUserMedia) {
		alert('MediaRecorder not supported on your browser, use Firefox 30+ or Chrome 49+ instead.');
	}else {
		navigator.getUserMedia(constraints_audio, startRecording_{ID}_audio, errorCallback);
		recBtn_{ID}_audio.disabled = true;
		confirmBtn_{ID}_audio.disabled = true;
		pauseResBtn_{ID}_audio.disabled = false;
		stopBtn_{ID}_audio.disabled = false;
	}
}

function onBtnStopClicked_{ID}_audio(){
	mediaRecorder.stop();
	mediaElement_{ID}_audio.controls = true;
	$("#media_{ID}_audio").prop('muted', false);
	//$('#visualizer_{ID}_audio').hide();

	recBtn_{ID}_audio.disabled = false;
	confirmBtn_{ID}_audio.disabled = false;
	pauseResBtn_{ID}_audio.disabled = true;
	stopBtn_{ID}_audio.disabled = true;
}

function onPauseResumeClicked_{ID}_audio(){
	if(pauseResBtn_{ID}_audio.textContent === "Pause"){
		console.log("pause");
		pauseResBtn_{ID}_audio.textContent = "Resume";
		mediaRecorder.pause();
		stopBtn_{ID}_audio.disabled = true;
	}else{
		console.log("resume");
		pauseResBtn_{ID}_audio.textContent = "Pause";
		mediaRecorder.resume();
		stopBtn_{ID}_audio.disabled = false;
	}
	recBtn_{ID}_audio.disabled = true;
	pauseResBtn_{ID}_audio.disabled = false;
}


function log_{ID}_audio(message){
	dataElement_{ID}_audio.innerHTML = dataElement_{ID}_audio.innerHTML+'<br>'+message ;
}



//browser ID
function getBrowser(){
	var nVer = navigator.appVersion;
	var nAgt = navigator.userAgent;
	var browserName  = navigator.appName;
	var fullVersion  = ''+parseFloat(navigator.appVersion);
	var majorVersion = parseInt(navigator.appVersion,10);
	var nameOffset,verOffset,ix;

	// In Opera, the true version is after "Opera" or after "Version"
	if ((verOffset=nAgt.indexOf("Opera"))!=-1) {
	 browserName = "Opera";
	 fullVersion = nAgt.substring(verOffset+6);
	 if ((verOffset=nAgt.indexOf("Version"))!=-1)
	   fullVersion = nAgt.substring(verOffset+8);
	}
	// In MSIE, the true version is after "MSIE" in userAgent
	else if ((verOffset=nAgt.indexOf("MSIE"))!=-1) {
	 browserName = "Microsoft Internet Explorer";
	 fullVersion = nAgt.substring(verOffset+5);
	}
	// In Chrome, the true version is after "Chrome"
	else if ((verOffset=nAgt.indexOf("Chrome"))!=-1) {
	 browserName = "Chrome";
	 fullVersion = nAgt.substring(verOffset+7);
	}
	// In Safari, the true version is after "Safari" or after "Version"
	else if ((verOffset=nAgt.indexOf("Safari"))!=-1) {
	 browserName = "Safari";
	 fullVersion = nAgt.substring(verOffset+7);
	 if ((verOffset=nAgt.indexOf("Version"))!=-1)
	   fullVersion = nAgt.substring(verOffset+8);
	}
	// In Firefox, the true version is after "Firefox"
	else if ((verOffset=nAgt.indexOf("Firefox"))!=-1) {
	 browserName = "Firefox";
	 fullVersion = nAgt.substring(verOffset+8);
	}
	// In most other browsers, "name/version" is at the end of userAgent
	else if ( (nameOffset=nAgt.lastIndexOf(' ')+1) <
		   (verOffset=nAgt.lastIndexOf('/')) )
	{
	 browserName = nAgt.substring(nameOffset,verOffset);
	 fullVersion = nAgt.substring(verOffset+1);
	 if (browserName.toLowerCase()==browserName.toUpperCase()) {
	  browserName = navigator.appName;
	 }
	}
	// trim the fullVersion string at semicolon/space if present
	if ((ix=fullVersion.indexOf(";"))!=-1)
	   fullVersion=fullVersion.substring(0,ix);
	if ((ix=fullVersion.indexOf(" "))!=-1)
	   fullVersion=fullVersion.substring(0,ix);

	majorVersion = parseInt(''+fullVersion,10);
	if (isNaN(majorVersion)) {
	 fullVersion  = ''+parseFloat(navigator.appVersion);
	 majorVersion = parseInt(navigator.appVersion,10);
	}


	return browserName;
}

// function visualize taken from https://github.com/mdn/web-dictaphone
function visualize(stream) {
	  var source = audioCtx_{ID}_audio.createMediaStreamSource(stream);

	  var analyser = audioCtx_{ID}_audio.createAnalyser();
	  analyser.fftSize = 2048;
	  var bufferLength = analyser.frequencyBinCount;
	  var dataArray = new Uint8Array(bufferLength);

	  source.connect(analyser);
	  //analyser.connect(audioCtx_{ID}_audio.destination);

	  draw()

	  function draw() {
	    WIDTH = canvas_{ID}_audio.width
	    HEIGHT = canvas_{ID}_audio.height;

	    requestAnimationFrame(draw);

	    analyser.getByteTimeDomainData(dataArray);

	    var color = $('.ilc_question_Standard').css("background-color");
	    canvasCtx_{ID}_audio.fillStyle = color;
	    canvasCtx_{ID}_audio.fillRect(0, 0, WIDTH, HEIGHT);

	    canvasCtx_{ID}_audio.lineWidth = 2;
	    canvasCtx_{ID}_audio.strokeStyle = 'rgb(0, 0, 0)';

	    canvasCtx_{ID}_audio.beginPath();

	    var sliceWidth = WIDTH * 1.0 / bufferLength;
	    var x = 0;


	    for(var i = 0; i < bufferLength; i++) {
	 
	      var v = dataArray[i] / 128.0;
	      var y = v * HEIGHT/2;

	      if(i === 0) {
	        canvasCtx_{ID}_audio.moveTo(x, y);
	      } else {
	        canvasCtx_{ID}_audio.lineTo(x, y);
	      }

	      x += sliceWidth;
	    }

	    canvasCtx_{ID}_audio.lineTo(canvas_{ID}_audio.width, canvas_{ID}_audio.height/2);
	    canvasCtx_{ID}_audio.stroke();

	  }
}

window.onresize = function() {
	  canvas_{ID}_audio.width = mainSection.offsetWidth;
}

window.onresize();
</script>
<input type="hidden" id="question_{ID}_audio" name="question_{ID}_audio"  value='{RESUME}'/>